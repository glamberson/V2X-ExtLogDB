Option Compare Database
' version 0.9.35
' Add these declarations at the top of your module
Private Declare PtrSafe Function GetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long
' Declare the Sleep function from Windows API
Private Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)

Private Type OPENFILENAME
    lStructSize As Long
    hwndOwner As LongPtr
    hInstance As LongPtr
    lpstrFilter As String
    lpstrCustomFilter As String
    nMaxCustFilter As Long
    nFilterIndex As Long
    lpstrFile As String
    nMaxFile As Long
    lpstrFileTitle As String
    nMaxFileTitle As Long
    lpstrInitialDir As String
    lpstrTitle As String
    Flags As Long
    nFileOffset As Integer
    nFileExtension As Integer
    lpstrDefExt As String
    lCustData As LongPtr
    lpfnHook As LongPtr
    lpTemplateName As String
End Type

' Import And Insert MRL Line Items
' version 0.9.34

Sub ImportAndInsertMRLLineItems()
    Dim xlApp As Object
    Dim xlWorkbook As Object
    Dim xlSheet As Object
    Dim columnLookup As Object
    Dim validationRules As New Collection
    Dim isValid As Boolean
    Dim filePath As String
    
    On Error GoTo ErrorHandler
    
    Debug.Print "Starting ImportAndInsertMRLLineItems"
    
    ' Use the SelectExcelFile function
    filePath = SelectExcelFile()
    Debug.Print "After SelectExcelFile, filePath = " & filePath
    
    If filePath = "" Then
        MsgBox "No file selected. Process aborted.", vbExclamation
        Exit Sub
    End If
    
    ' Create a new Excel application instance
    Set xlApp = CreateObject("Excel.Application")
    Debug.Print "Excel application created"
    
    ' Open the workbook (writable mode to allow preprocessing)
    Set xlWorkbook = xlApp.Workbooks.Open(filePath)
    Debug.Print "Workbook opened: " & xlWorkbook.Name
    
    ' Use the reusable function to select the worksheet
    Set xlSheet = SelectWorksheet(xlWorkbook)
    If xlSheet Is Nothing Then
        Debug.Print "No worksheet selected"
        GoTo Cleanup
    End If
    Debug.Print "Selected worksheet: " & xlSheet.Name
    
    ' Clean up the column names before proceeding
    Call CleanUpColumnNames(xlSheet, 1)
    Debug.Print "Column names cleaned up"
    
    ' Clean up the data before validation
    Call CleanUpData(xlSheet, 1)
    Debug.Print "Data cleaned up"
    
    ' Build the column lookup table
    Set columnLookup = BuildColumnLookup(xlSheet, 1)
    Debug.Print "Column lookup table built"
    
    ' Proceed with importing the data
    Call ImportExcelToAccess(filePath)
    Debug.Print "Excel data imported to Access"
    
    Call InsertMRLLineItems
    Debug.Print "MRL Line Items inserted"
    
    MsgBox "Import and insert process completed successfully.", vbInformation
    
    GoTo Cleanup

ErrorHandler:
    Debug.Print "Error in ImportAndInsertMRLLineItems: " & Err.description & " (Error " & Err.Number & ")"
    Debug.Print "Error Source: " & Err.Source
    MsgBox "An error occurred: " & Err.description, vbExclamation

Cleanup:
    On Error Resume Next
    Debug.Print "Starting cleanup"

    ' Explicitly set the sheet reference to Nothing
    Set xlSheet = Nothing
    Debug.Print "xlSheet reference cleared"
    
    ' Close the workbook without saving any changes
    If Not xlWorkbook Is Nothing Then
        xlWorkbook.Close SaveChanges:=False ' Explicitly discard changes
        Debug.Print "Workbook closed"
    End If
    
    ' Explicitly set the workbook reference to Nothing
    Set xlWorkbook = Nothing
    Debug.Print "xlWorkbook reference cleared"
    
    ' Quit the Excel application
    If Not xlApp Is Nothing Then
        xlApp.Quit
        Debug.Print "Excel application quit"
    End If
    
    ' Explicitly set the application reference to Nothing
    Set xlApp = Nothing
    Debug.Print "xlApp reference cleared"

    ' Use the Sleep API to pause briefly, allowing Windows to release file handles
    Sleep 1000 ' Wait for 1 second to allow the OS to release file locks

    ' Optionally, kill any lingering Excel processes
    KillExcelProcesses

    Debug.Print "Cleanup completed"
End Sub

' ImportAndUpdateFulfillmentItems
' version 0.9.34
Sub ImportAndUpdateFulfillmentItems()
    Dim xlApp As Object
    Dim xlWorkbook As Object
    Dim xlSheet As Object
    Dim columnLookup As Object
    Dim validationRules As New Collection
    Dim isValid As Boolean
    Dim filePath As String
    
    On Error GoTo ErrorHandler
    
    Debug.Print "Starting ImportAndUpdateFulfillmentItems"
    
    ' Use the SelectExcelFile function
    filePath = SelectExcelFile()
    Debug.Print "After SelectExcelFile, filePath = " & filePath
    
    If filePath = "" Then
        MsgBox "No file selected. Process aborted.", vbExclamation
        Exit Sub
    End If
    
    ' Create a new Excel application instance
    Set xlApp = CreateObject("Excel.Application")
    Debug.Print "Excel application created"
    
    ' Open the workbook (writable mode to allow preprocessing)
    Set xlWorkbook = xlApp.Workbooks.Open(filePath)
    Debug.Print "Workbook opened: " & xlWorkbook.Name
    
    ' Use the reusable function to select the worksheet
    Set xlSheet = SelectWorksheet(xlWorkbook)
    If xlSheet Is Nothing Then
        Debug.Print "No worksheet selected"
        GoTo Cleanup
    End If
    Debug.Print "Selected worksheet: " & xlSheet.Name
    
    ' Clean up the column names before proceeding
    Call CleanUpColumnNames(xlSheet, 1)
    Debug.Print "Column names cleaned up"
    
    ' Clean up the data before validation
    Call CleanUpData(xlSheet, 1)
    Debug.Print "Data cleaned up"
    
    ' Build the column lookup table
    Set columnLookup = BuildColumnLookup(xlSheet, 1)
    Debug.Print "Column lookup table built"
    
    ' Proceed with importing the data
    Call ImportExcelToAccess(filePath)
    Debug.Print "Excel data imported to Access"
    
    Call UpdateFulfillmentItems
    Debug.Print "Fulfillment records updated"
    
    MsgBox "Import and update process completed successfully.", vbInformation
    
    GoTo Cleanup

ErrorHandler:
    Debug.Print "Error in ImportAndUpdateFulfillmentItems: " & Err.description & " (Error " & Err.Number & ")"
    Debug.Print "Error Source: " & Err.Source
    MsgBox "An error occurred: " & Err.description, vbExclamation

Cleanup:
    On Error Resume Next
    Debug.Print "Starting cleanup"

    ' Explicitly set the sheet reference to Nothing
    Set xlSheet = Nothing
    Debug.Print "xlSheet reference cleared"
    
    ' Close the workbook without saving any changes
    If Not xlWorkbook Is Nothing Then
        xlWorkbook.Close SaveChanges:=False ' Explicitly discard changes
        Debug.Print "Workbook closed"
    End If
    
    ' Explicitly set the workbook reference to Nothing
    Set xlWorkbook = Nothing
    Debug.Print "xlWorkbook reference cleared"
    
    ' Quit the Excel application
    If Not xlApp Is Nothing Then
        xlApp.Quit
        Debug.Print "Excel application quit"
    End If
    
    ' Explicitly set the application reference to Nothing
    Set xlApp = Nothing
    Debug.Print "xlApp reference cleared"

    ' Use the Sleep API to pause briefly, allowing Windows to release file handles
    Sleep 1000 ' Wait for 1 second to allow the OS to release file locks

    ' Optionally, kill any lingering Excel processes
    KillExcelProcesses

    Debug.Print "Cleanup completed"
End Sub

' Select Excel File (Windows API)
' version 0.9.10

Public Function SelectExcelFile() As String
    On Error GoTo ErrorHandler
    
    Debug.Print "Starting SelectExcelFile function"
    
    Dim OpenFile As OPENFILENAME
    Dim lReturn As Long
    Dim sFilter As String
    
    'Set the structure size
    OpenFile.lStructSize = LenB(OpenFile)
    
    'Set the filter
    sFilter = "Excel Files (*.xlsx; *.xls)" & Chr(0) & "*.xlsx;*.xls" & Chr(0) & "All Files (*.*)" & Chr(0) & "*.*" & Chr(0)
    OpenFile.lpstrFilter = sFilter
    
    'Set the maximum number of characters
    OpenFile.nMaxFile = 260
    
    'Create a string buffer
    OpenFile.lpstrFile = String(OpenFile.nMaxFile, 0)
    
    'Set the initial directory (optional, you can comment this out if not needed)
    OpenFile.lpstrInitialDir = CurDir
    
    'Set the dialog box title
    OpenFile.lpstrTitle = "Select Excel File"
    
    'No flags
    OpenFile.Flags = 0
    
    Debug.Print "About to call GetOpenFileName"
    'Show the 'Open File' dialog box
    lReturn = GetOpenFileName(OpenFile)
    
    Debug.Print "GetOpenFileName returned: " & lReturn
    
    If lReturn <> 0 Then
        SelectExcelFile = Left(OpenFile.lpstrFile, InStr(OpenFile.lpstrFile, vbNullChar) - 1)
        Debug.Print "Selected file: " & SelectExcelFile
    Else
        SelectExcelFile = ""
        Debug.Print "No file selected"
    End If
    
    Exit Function

ErrorHandler:
    Debug.Print "Error in SelectExcelFile: " & Err.description
    SelectExcelFile = ""
End Function

' Select Worksheet
' verison 0.9.15

Public Function SelectWorksheet(xlWorkbook As Object) As Object
    Dim sheetName As String
    Dim xlSheet As Object
    
    ' Prompt the user to select a sheet
    sheetName = InputBox("Enter the name of the sheet to use:", "Select Sheet", xlWorkbook.Sheets(1).Name)
    
    ' Validate the selected sheet name
    On Error Resume Next
    Set xlSheet = xlWorkbook.Sheets(sheetName)
    On Error GoTo 0
    
    If xlSheet Is Nothing Then
        MsgBox "The sheet named '" & sheetName & "' does not exist. Please check the sheet name and try again.", vbExclamation
    End If
    
    Set SelectWorksheet = xlSheet
End Function

' Clean Up Column Names
' version 0.9.15

Public Sub CleanUpColumnNames(sheet As Object, headerRow As Integer)
    Dim col As Integer
    Dim colName As String
    
    For col = 1 To 200 ' Limit to the first 200 columns
        colName = sheet.Cells(headerRow, col).Value
        If IsEmpty(colName) Then Exit For
        
        ' Trim leading and trailing spaces
        colName = Trim(colName)
        
        ' Convert to lowercase
        colName = LCase(colName)
        
        ' Replace multiple spaces, dashes, and slashes with a single underscore
        colName = Replace(colName, " ", "_")
        colName = Replace(colName, "-", "_")
        colName = Replace(colName, "/", "_")
        
        ' Handle multiple underscores caused by consecutive replacements
        Do While InStr(colName, "__") > 0
            colName = Replace(colName, "__", "_")
        Loop
        
        ' Update the column name in the sheet
        sheet.Cells(headerRow, col).Value = colName
    Next col
End Sub

' Clean Up Data
' version 0.9.15

Public Sub CleanUpData(sheet As Object, headerRow As Integer)
    Dim col As Integer
    Dim row As Integer
    Dim lastRow As Long
    Dim lastCol As Long
    Dim cellValue As Variant
    
    ' Find the last used row and column
    lastRow = sheet.Cells(sheet.Rows.count, 1).End(-4162).row ' Find the last row with data in column 1
    lastCol = sheet.Cells(headerRow, sheet.Columns.count).End(-4159).Column ' Find the last column with data in the header row
    
    For col = 1 To lastCol ' Only iterate through the relevant columns
        For row = headerRow + 1 To lastRow ' Only iterate through the relevant rows
            cellValue = sheet.Cells(row, col).Value
            
            ' Check if cell is numeric text with leading apostrophe
            If IsNumeric(cellValue) And Left(cellValue, 1) = "'" Then
                sheet.Cells(row, col).Value = Val(cellValue)
            ' Check if cell is numeric but stored as text
            ElseIf IsNumeric(cellValue) And VarType(cellValue) = vbString Then
                sheet.Cells(row, col).Value = Val(cellValue)
            End If
            
            ' Trim leading and trailing spaces
            If VarType(cellValue) = vbString Then
                sheet.Cells(row, col).Value = Trim(cellValue)
            End If
        Next row
    Next col
End Sub

' BuildColumnLookup function to dynamically create a dictionary of column names
' version 0.9.15

Public Function BuildColumnLookup(sheet As Object, headerRow As Integer) As Object
    Dim col As Integer
    Dim columnLookup As Object
    Set columnLookup = CreateObject("Scripting.Dictionary")
    
    ' Search the first 200 columns
    For col = 1 To 200
        If IsEmpty(sheet.Cells(headerRow, col).Value) Then Exit For
        columnLookup(LCase(Trim(sheet.Cells(headerRow, col).Value))) = col
    Next col
    
    Set BuildColumnLookup = columnLookup
End Function

' Validate if JCN is not empty
' version 0.9.02
Public Function ValidateJCN(xlSheet As Object, row As Integer, columnLookup As Object) As Boolean
    Dim colJCN As Integer
    If columnLookup.Exists("jcn") Then
        colJCN = columnLookup("jcn")
    Else
        MsgBox "Error: JCN column not found."
        ValidateJCN = False
        Exit Function
    End If
    
    If IsEmpty(xlSheet.Cells(row, colJCN)) Then
        MsgBox "Error: jcn is required at row " & row
        ValidateJCN = False
    Else
        ValidateJCN = True
    End If
End Function

' Validate if TWCODE is not empty
' version 0.9.02
Public Function ValidateTWCODE(xlSheet As Object, row As Integer, columnLookup As Object) As Boolean
    Dim colTWCODE As Integer
    If columnLookup.Exists("twcode") Then
        colTWCODE = columnLookup("twcode")
    Else
        MsgBox "Error: TWCODE column not found."
        ValidateTWCODE = False
        Exit Function
    End If
    
    If IsEmpty(xlSheet.Cells(row, colTWCODE)) Then
        MsgBox "Error: twcode is required at row " & row
        ValidateTWCODE = False
    Else
        ValidateTWCODE = True
    End If
End Function

' Validate qty field
'version 0.9.02

Function ValidateQty(qty As Variant) As Boolean
    ' Initialize the result to False
    ValidateQty = False
    
    ' Check if the qty is numeric and greater than zero
    If IsNumeric(qty) Then
        If qty > 0 Then
            ValidateQty = True
        End If
    End If
End Function

' Validate Request Date
' version 0.9.02

Function ValidateRequestDate(requestDate As Variant) As Boolean
    ' Initialize the result to False
    ValidateRequestDate = False
    
    ' Check if the requestDate is populated and is a valid date
    If Not IsNull(requestDate) Then
        If IsDate(requestDate) Then
            ValidateRequestDate = True
        End If
    End If
End Function

' Additional validation functions can be implemented similarly

' Validate Excel Data
' version 0.9.15

Public Function ValidateExcelData(xlSheet As Object, validationRules As Collection, columnLookup As Object) As Boolean
    Dim row As Integer
    Dim isValid As Boolean
    Dim rule As Variant
    isValid = True

    ' Iterate through each row and apply validation rules
    For row = 2 To xlSheet.Cells(xlSheet.Rows.count, 1).End(-4162).row
        For Each rule In validationRules
            If Not rule(xlSheet, row, columnLookup) Then
                isValid = False
                Exit For
            End If
        Next rule
        
        If Not isValid Then Exit For
    Next row

    ValidateExcelData = isValid
End Function

' Import Excel To Access
' version 0.9.21

Sub ImportExcelToAccess(filePath As String)
    Dim db As DAO.Database
    
    On Error GoTo ErrorHandler
    
    Debug.Print "Starting ImportExcelToAccess"
    
    ' Delete TempTable if it exists
    Set db = CurrentDb()
    On Error Resume Next
    db.Execute "DROP TABLE TempTable"
    On Error GoTo ErrorHandler
    
    ' Import the Excel sheet data into the Access TempTable
    DoCmd.TransferSpreadsheet acImport, acSpreadsheetTypeExcel12, "TempTable", filePath, True
    Debug.Print "Data imported to TempTable from: " & filePath
    
    GoTo Cleanup

ErrorHandler:
    Debug.Print "Error in ImportExcelToAccess: " & Err.description
    MsgBox "An error occurred while importing the Excel data: " & Err.description, vbExclamation

Cleanup:
    Set db = Nothing
    Debug.Print "ImportExcelToAccess completed"
End Sub

' Kill Excel Processes
' version 0.9.34

Sub KillExcelProcesses()
    Dim objWMI As Object, colProcess As Object, objProcess As Object
    Set objWMI = GetObject("winmgmts:\\.\root\cimv2")
    Set colProcess = objWMI.ExecQuery("Select * from Win32_Process Where Name = 'EXCEL.EXE'")
    
    For Each objProcess In colProcess
        objProcess.Terminate
    Next objProcess
End Sub

