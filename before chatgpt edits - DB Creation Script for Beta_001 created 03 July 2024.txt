-- DB Creation Script for Beta_001 created 03 July 2024



-- Enable pgcrypto extension if not already enabled
CREATE EXTENSION IF NOT EXISTS pgcrypto;


CREATE TABLE roles (
    role_id SERIAL PRIMARY KEY, -- Unique identifier for the role
    role_name VARCHAR(100) UNIQUE NOT NULL -- Name of the role, must be unique
);

-- Insert predefined roles
INSERT INTO roles (role_name) VALUES
    ('KPPO Admin'),
    ('Chesapeake Warehouse'),
    ('NAVSUP'),
    ('Logistics Service Center (LSC)');


CREATE TABLE users (
    user_id SERIAL PRIMARY KEY, -- Unique identifier for the user
    username VARCHAR(100) UNIQUE NOT NULL, -- Username, must be unique
    password_hash VARCHAR(255) NOT NULL, -- Hashed password for the user
    role_id INT REFERENCES roles(role_id), -- Foreign key to roles table
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP -- Timestamp when the user was created
);

-- Insert sample users with hashed passwords and role IDs
INSERT INTO users (username, password_hash, role_id) VALUES
    ('admin', crypt('admin_password', gen_salt('bf')), 1),
    ('chesapeake_user', crypt('chesapeake_password', gen_salt('bf')), 2),
    ('navsup_user', crypt('navsup_password', gen_salt('bf')), 3),
    ('lsc_user', crypt('lsc_password', gen_salt('bf')), 4);

CREATE TABLE statuses (
    status_id SERIAL PRIMARY KEY, -- Unique identifier for the status
    status_name VARCHAR(50) UNIQUE NOT NULL, -- Name of the status, must be unique
    status_value INT NOT NULL -- Numeric value representing the status progression
);

-- Insert predefined statuses with the correct order
INSERT INTO statuses (status_name, status_value) VALUES
    ('NOT ORDERED', 10),
    ('INIT PROCESS', 20),
    ('ON ORDER', 30),
    ('RCD CHES WH', 40),
    ('PROC CHES WH', 50),
    ('READY TO SHIP', 60),
    ('FREIGHT FORWARDER', 70),
    ('EN ROUTE TO EGYPT', 80),
    ('ADMINISTRATIVELY REORDERED', 85),
    ('ARR EGYPT', 90),
    ('CORRECTION', 95),
    ('PARTIALLY RECEIVED', 100),
    ('ON HAND EGYPT', 110);

CREATE TABLE MRL_line_items (
    order_line_item_id SERIAL PRIMARY KEY, -- Internal unique identifier for the MRL line item record, not published or used externally
    jcn VARCHAR(50) NOT NULL, -- Job Control Number, unique identifier for work orders, old IMDS, or manually generated orders
    twcode VARCHAR(50) NOT NULL, -- Technical Writer Code, combined with JCN for unique identification
    nomenclature TEXT, -- Noun description of material being ordered
    cog VARCHAR(10), -- Cognizance Symbol, two-position prefix for supply management information
    fsc VARCHAR(10), -- Federal Supply Classification, four-digit code for supply items
    niin VARCHAR(20), -- NATO Item Identification Number, last 9 digits of NSN, unique to the item
    part_no VARCHAR(50), -- Part number of the item
    qty INT, -- Quantity of the item to be ordered
    ui VARCHAR(10), -- Unit of Issue (Unit of Measure), determines the measuring unit for the material
    market_research_up MONEY, -- Unit price in USD determined by market research (Haystack GOLD or historical info)
    market_research_ep MONEY, -- Total estimated price in USD (unit price * quantity), based on market research
    availability_identifier VARCHAR(50) REFERENCES availability_events(availability_identifier), -- Internal availability identifier used in CMMS
    request_date DATE, -- Date when the LSC submits the line item for fulfillment/procurement
    rdd DATE, -- Required Delivery Date, the date by which an item must be received in Egypt
    pri VARCHAR(10), -- Priority level set for the procurement of the item
    swlin VARCHAR(20), -- Secondary Work Line Item Number
    hull_or_shop VARCHAR(20), -- Specifies whether the item is designated for a ship (hull) or a shop
    suggested_source TEXT, -- Recommended vendor and contact/shipping information
    mfg_cage VARCHAR(20), -- Manufacturer CAGE Code, unique identifier for manufacturers/suppliers
    apl VARCHAR(50), -- Allowance Parts List, authorized list of parts for maintenance and repair
    nha_equipment_system TEXT, -- Equipment system associated with the NHA
    nha_model TEXT, -- Model of the NHA
    nha_serial TEXT, -- Serial number of the NHA
    techmanual TEXT, -- Technical manual where the specified material is referenced (e.g., JFMM, NSTM)
    dwg_pc TEXT, -- Drawing/Illustration reference in the technical manual where the item is specified
    requestor_remarks TEXT, -- Notes added by KPPO Material Manager for processing or clarification
    inquiry_status BOOLEAN DEFAULT FALSE, -- Flag set when review of the line item is requested
    created_by INT REFERENCES roles(role_id), -- User who created the line item in this database
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP, -- Timestamp with time zone
    status_id INT REFERENCES statuses(status_id), -- Foreign key to statuses table
    received_quantity INT DEFAULT 0, -- Tracks the number of units received, useful for multiple fulfillment records
    has_comments BOOLEAN DEFAULT FALSE, -- Indicates if any user comments have been added for the line item
    multiple_fulfillments BOOLEAN DEFAULT FALSE, -- Indicates if the line item has more than one fulfillment record
    UNIQUE (jcn, twcode) -- Ensures unique combination of JCN and TWCODE
);


CREATE TABLE fulfillment_items (
    fulfillment_item_id SERIAL PRIMARY KEY, -- Unique identifier for the fulfillment record
    order_line_item_id INT NOT NULL REFERENCES MRL_line_items(order_line_item_id) ON DELETE CASCADE, -- Foreign key to MRL line items
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP, -- Timestamp when the fulfillment record was created
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP, -- Timestamp when the fulfillment record was last updated
    milstrip_req_no VARCHAR(50), -- Requisition or MILSTRIP number
    edd_to_ches DATE, -- Estimated delivery date to Chesapeake
    rcd_v2x_date DATE, -- Received at V2X date
    lot_id VARCHAR(15), -- Lot identifier
    triwall VARCHAR(15), -- Tri-wall identifier
    shipdoc_tcn VARCHAR(30), -- Shipping document TCN
    v2x_ship_no VARCHAR(20), -- V2X shipment number
    booking VARCHAR(20), -- Booking number
    vessel VARCHAR(30), -- Vessel name
    container VARCHAR(25), -- Container number
    sail_date DATE, -- Sail date
    edd_to_egypt DATE, -- Estimated delivery date to Egypt
    arr_lsc_egypt DATE, -- Arrival at LSC Egypt
    lsc_on_hand_date DATE, -- LSC on-hand date
    carrier VARCHAR(50), -- Carrier information for the shipment
    status_id INT REFERENCES statuses(status_id), -- Foreign key to statuses table
    created_by INT REFERENCES roles(role_id), -- User who created the fulfillment record
    updated_by VARCHAR(50), -- User who last updated the fulfillment record
    update_source VARCHAR(50) --where the most recent update comes from
    has_comments BOOLEAN DEFAULT FALSE, -- Indicates if any user comments have been added for the fulfillment record
    inquiry_status BOOLEAN DEFAULT FALSE, -- Flag set when review of the fulfillment record is requested
    UNIQUE (order_line_item_id, fulfillment_item_id) -- Ensures unique combination of order line item and fulfillment record
);


CREATE TABLE audit_trail (
    audit_id SERIAL PRIMARY KEY, -- Unique identifier for the audit record
    order_line_item_id INT REFERENCES MRL_line_items(order_line_item_id) ON DELETE CASCADE, -- Foreign key to MRL line items
    action VARCHAR(100), -- Description of the action taken
    changed_by VARCHAR(50), -- User who made the change
    changed_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP, -- Timestamp when the change was made
    details TEXT, -- Detailed description of the change
    role_id INT REFERENCES roles(role_id), -- Foreign key to roles table
    user_id INT REFERENCES users(user_id) -- Foreign key to users table
);


CREATE TABLE line_item_comments (
    comment_id SERIAL PRIMARY KEY, -- Unique identifier for the comment
    order_line_item_id INT, -- Foreign key to MRL line items or fulfillment items
    fulfillment_item_id INT, -- Foreign key to fulfillment items or NULL if it refers to MRL line item
    comment TEXT, -- The comment text
    commented_by VARCHAR(100), -- User who made the comment
    commented_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP, -- Timestamp with timezone when the comment was made
    role_id INT REFERENCES roles(role_id), -- Foreign key to roles table
    CHECK ((order_line_item_id IS NOT NULL AND fulfillment_item_id IS NULL) OR 
           (order_line_item_id IS NULL AND fulfillment_item_id IS NOT NULL)) -- Ensure only one of the two fields is set
);


CREATE TABLE line_item_inquiry (
    inquiry_id SERIAL PRIMARY KEY, -- Unique identifier for the inquiry record
    order_line_item_id INT REFERENCES MRL_line_items(order_line_item_id) ON DELETE CASCADE, -- Foreign key to MRL line items
    inquiry_status BOOLEAN, -- Status of the inquiry (e.g., TRUE for active inquiry, FALSE for resolved)
    updated_by VARCHAR(50), -- User who updated the inquiry status
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP, -- Timestamp when the inquiry status was updated
    role_id INT REFERENCES roles(role_id) -- Foreign key to roles table
);


CREATE TABLE user_activity (
    activity_id SERIAL PRIMARY KEY, -- Unique identifier for the activity record
    user_id INT REFERENCES users(user_id) ON DELETE CASCADE, -- Foreign key to users table
    activity_type VARCHAR(50) NOT NULL, -- Type of activity (e.g., 'login', 'logout', 'failed_login')
    activity_time TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP, -- Timestamp when the activity occurred
    activity_details TEXT -- Additional details about the activity
);


CREATE TABLE availability_events (
    availability_event_id SERIAL PRIMARY KEY, -- Unique identifier for the availability event
    availability_identifier VARCHAR(50) UNIQUE NOT NULL, -- Internal availability identifier used in CMMS
    availability_name VARCHAR(100) NOT NULL, -- Name of the availability event
    start_date DATE NOT NULL, -- Start date of the availability event
    end_date DATE NOT NULL, -- End date of the availability event
    description TEXT, -- Description of the availability event
    created_by INT REFERENCES users(user_id), -- User who created the availability event
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP -- Timestamp when the availability event was created
);


CREATE TABLE temp_bulk_update (
    fulfillment_item_id SERIAL PRIMARY KEY,
    order_line_item_id INT,
    edd_to_ches DATE,
    rcd_v2x_date DATE,
    lot_id VARCHAR(15),
    triwall VARCHAR(15),
    shipdoc_tcn VARCHAR(30),
    v2x_ship_no VARCHAR(20),
    booking VARCHAR(20),
    vessel VARCHAR(30),
    container VARCHAR(25),
    sail_date DATE,
    edd_to_egypt DATE,
    arr_lsc_egypt DATE,
    lsc_on_hand_date DATE,
    carrier VARCHAR(50),
    status_id INT REFERENCES statuses(status_id),
    flag_for_review BOOLEAN DEFAULT FALSE,
    reason TEXT
);



CREATE OR REPLACE FUNCTION audit_fulfillment_update()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO audit_trail (
        order_line_item_id, 
        fulfillment_item_id, 
        action, 
        changed_by, 
        details, 
        update_source, 
        changed_at
    )
    VALUES (
        NEW.order_line_item_id, 
        NEW.fulfillment_item_id, 
        'Update', 
        NEW.updated_by, 
        'Fulfillment record updated', 
        NEW.update_source, 
        NOW()
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER trigger_audit_fulfillment_item_updates
AFTER UPDATE ON fulfillment_items
FOR EACH ROW EXECUTE FUNCTION audit_fulfillment_item_updates();



-- FUNCTIONS

CREATE OR REPLACE FUNCTION update_mrl_status()
RETURNS TRIGGER AS $$
BEGIN
    -- Update MRL line item status based on fulfillment records
    UPDATE MRL_line_items
    SET status_id = (
        SELECT MIN(s.status_value)
        FROM fulfillment_items fi
        JOIN statuses s ON fi.status_id = s.status_id
        WHERE fi.order_line_item_id = NEW.order_line_item_id
    ),
    multiple_fulfillments = (
        SELECT COUNT(*) > 1
        FROM fulfillment_items fi
        WHERE fi.order_line_item_id = NEW.order_line_item_id
    )
    WHERE order_line_item_id = NEW.order_line_item_id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION log_inquiry_status_change()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO audit_trail (order_line_item_id, action, changed_by, details, role_id, user_id)
    VALUES (
        NEW.order_line_item_id,
        'Inquiry Status Updated',
        NEW.updated_by,
        'Inquiry Status '  NEW.inquiry_status,
        NEW.role_id,
        (SELECT user_id FROM users WHERE username = NEW.updated_by)
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION add_line_item_comment (
    p_order_line_item_id INT,
    p_fulfillment_item_id INT,
    p_comment TEXT,
    p_commented_by VARCHAR,
    p_role_id INT
)
RETURNS VOID AS $$
BEGIN
    INSERT INTO line_item_comments (order_line_item_id, fulfillment_item_id, comment, commented_by, commented_at, role_id)
    VALUES (p_order_line_item_id, p_fulfillment_item_id, p_comment, p_commented_by, CURRENT_TIMESTAMP AT TIME ZONE 'UTC', p_role_id);

    -- Update the has_comments field in MRL_line_items or fulfillment_items
    IF p_order_line_item_id IS NOT NULL THEN
        UPDATE MRL_line_items
        SET has_comments = TRUE
        WHERE order_line_item_id = p_order_line_item_id;
    ELSE
        UPDATE fulfillment_items
        SET has_comments = TRUE
        WHERE fulfillment_item_id = p_fulfillment_item_id;
    END IF;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION log_line_item_comment()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO audit_trail (order_line_item_id, action, changed_by, details, role_id, user_id)
    VALUES (
        NEW.order_line_item_id,
        'Comment Added',
        NEW.commented_by,
        'Comment: ' || NEW.comment,
        NEW.role_id,
        (SELECT user_id FROM users WHERE username = NEW.commented_by)
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION audit_fulfillment_update()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO audit_trail (
        order_line_item_id, 
        fulfillment_item_id, 
        action, 
        changed_by, 
        details, 
        update_source, 
        changed_at
    )
    VALUES (
        NEW.order_line_item_id, 
        NEW.fulfillment_item_id, 
        'Update', 
        NEW.updated_by, 
        'Fulfillment record updated', 
        NEW.update_source, 
        NOW()
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER trigger_audit_fulfillment_updates
AFTER UPDATE ON fulfillment_items
FOR EACH ROW EXECUTE FUNCTION audit_fulfillment_updates();


CREATE OR REPLACE FUNCTION update_mrl_line_item(
    p_order_line_item_id INT,
    p_field_name VARCHAR,
    p_new_value TEXT,
    p_updated_by VARCHAR,
    p_role_id INT
)
RETURNS VOID AS $$
BEGIN
    -- Construct dynamic SQL to update the specified field
    EXECUTE 'UPDATE MRL_line_items SET ' || p_field_name || ' = $1 WHERE order_line_item_id = $2'
    USING p_new_value, p_order_line_item_id;

    -- Log the update in the audit trail
    INSERT INTO audit_trail (order_line_item_id, action, changed_by, details, role_id, user_id)
    VALUES (
        p_order_line_item_id,
        'Update',
        p_updated_by,
        'Updated ' || p_field_name || ' to ' || p_new_value,
        p_role_id,
        (SELECT user_id FROM users WHERE username = p_updated_by)
    );
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION add_line_item_comment (
    p_order_line_item_id INT,
    p_fulfillment_item_id INT,
    p_comment TEXT,
    p_commented_by VARCHAR,
    p_role_id INT
)
RETURNS VOID AS $$
BEGIN
    INSERT INTO line_item_comments (order_line_item_id, fulfillment_item_id, comment, commented_by, commented_at, role_id)
    VALUES (p_order_line_item_id, p_fulfillment_item_id, p_comment, p_commented_by, CURRENT_TIMESTAMP AT TIME ZONE 'UTC', p_role_id);

    -- Update the has_comments field in MRL_line_items or fulfillment_items
    IF p_order_line_item_id IS NOT NULL THEN
        UPDATE MRL_line_items
        SET has_comments = TRUE
        WHERE order_line_item_id = p_order_line_item_id;
    ELSE
        UPDATE fulfillment_items
        SET has_comments = TRUE
        WHERE fulfillment_item_id = p_fulfillment_item_id;
    END IF;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION update_fulfillment_item(
    p_fulfillment_item_id INT,
    p_field_name VARCHAR,
    p_new_value TEXT,
    p_updated_by VARCHAR,
    p_update_source VARCHAR,
    p_role_id INT
)
RETURNS VOID AS $$
BEGIN
    -- Construct dynamic SQL to update the specified field
    EXECUTE 'UPDATE fulfillment_items SET ' || p_field_name || ' = $1, updated_by = $2, updated_at = CURRENT_TIMESTAMP WHERE fulfillment_item_id = $3'
    USING p_new_value, p_updated_by, p_fulfillment_item_id;

    -- Log the update in the audit trail
    INSERT INTO audit_trail (order_line_item_id, action, changed_by, details, role_id, user_id)
    VALUES (
        (SELECT order_line_item_id FROM fulfillment_items WHERE fulfillment_item_id = p_fulfillment_item_id),
        'Update',
        p_updated_by,
        'Updated ' || p_field_name || ' to ' || p_new_value,
        p_role_id,
        (SELECT user_id FROM users WHERE username = p_updated_by)
    );
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION update_inquiry_status_with_reason(
    p_order_line_item_id INT,
    p_inquiry_status BOOLEAN,
    p_reason TEXT,
    p_updated_by VARCHAR,
    p_role_id INT
)
RETURNS VOID AS $$
BEGIN
    -- Update the inquiry status
    INSERT INTO line_item_inquiry (order_line_item_id, inquiry_status, updated_by, updated_at, role_id)
    VALUES (p_order_line_item_id, p_inquiry_status, p_updated_by, CURRENT_TIMESTAMP AT TIME ZONE 'UTC', p_role_id)
    ON CONFLICT (order_line_item_id) DO UPDATE
    SET inquiry_status = EXCLUDED.inquiry_status,
        updated_by = EXCLUDED.updated_by,
        updated_at = EXCLUDED.updated_at,
        role_id = EXCLUDED.role_id;

    -- Log the update in the audit trail
    INSERT INTO audit_trail (order_line_item_id, action, changed_by, details, role_id, user_id)
    VALUES (
        p_order_line_item_id,
        'Inquiry Status Updated',
        p_updated_by,
        'Inquiry Status: ' || p_inquiry_status || ', Reason: ' || p_reason,
        p_role_id,
        (SELECT user_id FROM users WHERE username = p_updated_by)
    );
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION update_fulfillment_status()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.lsc_on_hand_date IS NOT NULL THEN
        NEW.status_id := (SELECT status_id FROM statuses WHERE status_name = 'ON HAND EGYPT');
    ELSIF NEW.arr_lsc_egypt IS NOT NULL THEN
        NEW.status_id := (SELECT status_id FROM statuses WHERE status_name = 'ARR EGYPT');
    ELSIF NEW.sail_date IS NOT NULL AND NEW.sail_date <= CURRENT_DATE THEN
        NEW.status_id := (SELECT status_id FROM statuses WHERE status_name = 'EN ROUTE TO EGYPT');
    ELSIF NEW.sail_date IS NOT NULL AND NEW.sail_date > CURRENT_DATE THEN
        NEW.status_id := (SELECT status_id FROM statuses WHERE status_name = 'FREIGHT FORWARDER');
    ELSIF NEW.shipdoc_tcn IS NOT NULL OR NEW.v2x_ship_no IS NOT NULL OR NEW.booking IS NOT NULL OR NEW.vessel IS NOT NULL OR NEW.container IS NOT NULL THEN
        NEW.status_id := (SELECT status_id FROM statuses WHERE status_name = 'READY TO SHIP');
    ELSIF NEW.lot_id IS NOT NULL AND NEW.triwall IS NOT NULL THEN
        NEW.status_id := (SELECT status_id FROM statuses WHERE status_name = 'PROC CHES WH');
    ELSIF NEW.rcd_v2x_date IS NOT NULL THEN
        NEW.status_id := (SELECT status_id FROM statuses WHERE status_name = 'RCD CHES WH');
    ELSIF NEW.edd_to_ches IS NOT NULL THEN
        NEW.status_id := (SELECT status_id FROM statuses WHERE status_name = 'ON ORDER');
    ELSIF NEW.milstrip_req_no IS NOT NULL THEN
        NEW.status_id := (SELECT status_id FROM statuses WHERE status_name = 'INIT PROCESS');
    ELSE
        NEW.status_id := (SELECT status_id FROM statuses WHERE status_name = 'NOT ORDERED');
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION user_login(
    p_username VARCHAR,
    p_password VARCHAR
)
RETURNS BOOLEAN AS $$
DECLARE
    v_user_id INT;
    v_role_id INT;
    v_password_hash VARCHAR;
    v_login_successful BOOLEAN := FALSE;
BEGIN
    -- Check if the user exists and get the password hash
    SELECT user_id, role_id, password_hash INTO v_user_id, v_role_id, v_password_hash
    FROM users
    WHERE username = p_username;

    -- Verify the password
    IF crypt(p_password, v_password_hash) = v_password_hash THEN
        v_login_successful := TRUE;

        -- Log the login activity
        PERFORM log_user_activity(v_user_id, 'login', 'User logged in');

        -- Also log this activity into the audit trail
        INSERT INTO audit_trail (order_line_item_id, action, changed_by, details, role_id, user_id)
        VALUES (
            NULL, -- No specific line item ID for general user activity
            'login',
            p_username,
            'User logged in',
            v_role_id,
            v_user_id
        );
    ELSE
        -- Log the failed login attempt
        PERFORM log_failed_login(p_username, 'Incorrect password');

        -- Also log this activity into the audit trail
        INSERT INTO audit_trail (order_line_item_id, action, changed_by, details, role_id, user_id)
        VALUES (
            NULL, -- No specific line item ID for general user activity
            'failed_login',
            p_username,
            'Incorrect password',
            NULL, -- No specific role for general user activity
            NULL -- No specific user ID for failed login
        );
    END IF;

    RETURN v_login_successful;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        -- Log the failed login attempt
        PERFORM log_failed_login(p_username, 'User not found');

        -- Also log this activity into the audit trail
        INSERT INTO audit_trail (order_line_item_id, action, changed_by, details, role_id, user_id)
        VALUES (
            NULL, -- No specific line item ID for general user activity
            'failed_login',
            p_username,
            'User not found',
            NULL, -- No specific role for general user activity
            NULL -- No specific user ID for failed login
        );

        RETURN FALSE;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION user_logout(
    p_user_id INT
)
RETURNS VOID AS $$
DECLARE
    v_username VARCHAR;
    v_role_id INT;
BEGIN
    -- Get the username and role ID
    SELECT username, role_id INTO v_username, v_role_id
    FROM users
    WHERE user_id = p_user_id;

    -- Log the logout activity
    PERFORM log_user_activity(p_user_id, 'logout', 'User logged out');

    -- Also log this activity into the audit trail
    INSERT INTO audit_trail (order_line_item_id, action, changed_by, details, role_id, user_id)
    VALUES (
        NULL, -- No specific line item ID for general user activity
        'logout',
        v_username,
        'User logged out',
        v_role_id,
        p_user_id
    );
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION view_line_item_history(p_order_line_item_id INT)
RETURNS TABLE (
    action_time TIMESTAMPTZ,
    action VARCHAR,
    changed_by VARCHAR,
    details TEXT,
    role_name VARCHAR,
    comment TEXT,
    comment_by VARCHAR,
    comment_time TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        at.changed_at AS action_time,
        at.action,
        at.changed_by,
        at.details,
        r.role_name,
        lc.comment,
        lc.commented_by AS comment_by,
        lc.commented_at AS comment_time
    FROM
        audit_trail at
    LEFT JOIN
        line_item_comments lc ON at.order_line_item_id = lc.order_line_item_id
    LEFT JOIN
        roles r ON at.role_id = r.role_id
    WHERE
        at.order_line_item_id = p_order_line_item_id
    ORDER BY
        at.changed_at, lc.commented_at;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE PROCEDURE batch_update_statuses(updates JSONB)
LANGUAGE plpgsql
AS $$
DECLARE
    update_item JSONB; -- Variable to hold each update item from the JSONB array
    record_id INT; -- Variable to hold the order_line_item_id from the update item
    new_status VARCHAR; -- Variable to hold the new status_name from the update item
BEGIN
    -- Loop through each item in the updates JSONB array
    FOR update_item IN SELECT * FROM jsonb_array_elements(updates)
    LOOP
        -- Extract the order_line_item_id and status_name from the update item
        record_id := (update_item->>'order_line_item_id')::INT;
        new_status := update_item->>'status_name';
        
        -- Update the status_id of the fulfillment item based on the new status_name
        UPDATE fulfillment_items
        SET status_id = (SELECT status_id FROM statuses WHERE status_name = new_status)
        WHERE order_line_item_id = record_id;

        -- Perform the MRL status update to reflect the changes
        PERFORM update_mrl_status();
    END LOOP;
END;
$$;

CREATE OR REPLACE FUNCTION process_bulk_update()
RETURNS VOID AS $$
BEGIN
    -- Update fulfillment items based on temp_bulk_update data
    UPDATE fulfillment_items fi
    SET 
        fi.edd_to_ches = tbu.edd_to_ches,
        fi.carrier = tbu.carrier,
        -- Add other columns as necessary
        fi.updated_at = NOW(),
        fi.updated_by = 'bulk_update',
        fi.update_source = tbu.update_source
    FROM temp_bulk_update tbu
    WHERE 
        tbu.order_line_item_id = fi.order_line_item_id 
        AND tbu.fulfillment_item_id = fi.fulfillment_item_id;

    -- Log the update in the audit trail
    INSERT INTO audit_trail (
        order_line_item_id, 
        fulfillment_item_id, 
        action, 
        changed_by, 
        details, 
        update_source, 
        changed_at
    )
    SELECT 
        tbu.order_line_item_id, 
        tbu.fulfillment_item_id, 
        'Bulk Update', 
        'admin_user', 
        tbu.reason, 
        tbu.update_source, 
        NOW()
    FROM temp_bulk_update tbu;

    -- Flag records with multiple fulfillment items
    UPDATE temp_bulk_update tbu
    SET flag_for_review = TRUE
    WHERE (
        SELECT COUNT(*) 
        FROM fulfillment_items fi 
        WHERE fi.order_line_item_id = tbu.order_line_item_id
    ) > 1;
END;
$$ LANGUAGE plpgsql;

-- Trigger for auditing line item updates
CREATE TRIGGER trigger_audit_line_item_update
AFTER UPDATE ON MRL_line_items
FOR EACH ROW EXECUTE FUNCTION audit_line_item_update();

-- Trigger for logging inquiry status changes
CREATE TRIGGER trigger_log_inquiry_status_change
AFTER INSERT OR UPDATE ON line_item_inquiry
FOR EACH ROW EXECUTE FUNCTION log_inquiry_status_change();

-- Trigger for logging line item comments
CREATE TRIGGER trigger_log_line_item_comment
AFTER INSERT ON line_item_comments
FOR EACH ROW EXECUTE FUNCTION log_line_item_comment();

-- Trigger for logging status changes
CREATE TRIGGER trigger_log_status_change
AFTER UPDATE ON fulfillment_items
FOR EACH ROW EXECUTE FUNCTION log_status_change();

-- Trigger for updating fulfillment status
CREATE TRIGGER trigger_update_fulfillment_status
BEFORE INSERT OR UPDATE ON fulfillment_items
FOR EACH ROW EXECUTE FUNCTION update_fulfillment_status();

-- Trigger for updating MRL status
CREATE TRIGGER trigger_update_mrl_status
AFTER INSERT OR UPDATE ON fulfillment_items
FOR EACH ROW EXECUTE FUNCTION update_mrl_status();

-- VIEWS

CREATE OR REPLACE VIEW audit_trail_view AS
SELECT 
    at.audit_id, -- Unique identifier for the audit record
    at.order_line_item_id, -- Foreign key to MRL line items
    m.jcn, -- Job Control Number from MRL line items
    m.twcode, -- Technical Writer Code from MRL line items
    at.action, -- Description of the action taken
    at.changed_by, -- User who made the change
    at.details, -- Detailed description of the change
    at.changed_at, -- Timestamp when the change was made
    r.role_name, -- Role name of the user who made the change
    u.username -- Username of the user who made the change
FROM 
    audit_trail at
JOIN 
    MRL_line_items m ON at.order_line_item_id = m.order_line_item_id -- Join with MRL line items for additional details
JOIN 
    roles r ON at.role_id = r.role_id -- Join with roles for role name
JOIN 
    users u ON at.user_id = u.user_id; -- Join with users for username


CREATE OR REPLACE VIEW availability_events_view AS
SELECT 
    ae.availability_event_id,
    ae.availability_name,
    ae.start_date,
    ae.end_date,
    ae.description,
    ae.created_at,
    u.username AS created_by
FROM 
    availability_events ae
JOIN 
    users u ON ae.created_by = u.user_id;


CREATE OR REPLACE VIEW line_item_inquiry_view AS
SELECT 
    li.inquiry_id,
    li.order_line_item_id,
    m.jcn,
    m.twcode,
    li.inquiry_status,
    li.updated_by,
    li.updated_at,
    r.role_name
FROM 
    line_item_inquiry li
JOIN 
    MRL_line_items m ON li.order_line_item_id = m.order_line_item_id
JOIN 
    roles r ON li.role_id = r.role_id;


CREATE OR REPLACE VIEW view_inquiry_status_items AS
SELECT 
    m.order_line_item_id,
    m.jcn,
    m.twcode,
    m.nomenclature,
    m.cog,
    m.fsc,
    m.niin,
    m.part_no,
    m.qty,
    m.ui,
    m.market_research_up,
    m.market_research_ep,
    m.availability_identifier, -- Updated field name
    m.request_date,
    m.rdd,
    m.pri,
    m.swlin,
    m.hull_or_shop,
    m.suggested_source,
    m.mfg_cage,
    m.apl,
    m.nha_equipment_system,
    m.nha_model,
    m.nha_serial,
    m.techmanual,
    m.dwg_pc,
    m.requestor_remarks,
    m.inquiry_status,
    m.created_by,
    m.created_at,
    m.status_id,
    m.received_quantity,
    m.has_comments,
    m.multiple_fulfillments, -- Updated field name
    li.inquiry_status AS current_inquiry_status,
    li.updated_by AS inquiry_updated_by,
    li.updated_at AS inquiry_updated_at
FROM 
    MRL_line_items m
JOIN 
    line_item_inquiry li ON m.order_line_item_id = li.order_line_item_id
WHERE 
    li.inquiry_status = TRUE
ORDER BY 
    li.updated_at DESC;



