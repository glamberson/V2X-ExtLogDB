
' import and insert mrl line items
' 0.7.12
Sub ImportAndInsertMRLLineItems()
    If Not ValidateExcelData() Then
        MsgBox "Data validation failed. Please correct the errors and try again."
        Exit Sub
    End If
    
    ImportExcelToAccess
    InsertMRLLineItems
    
End Sub

' import excel to access
' version 0.8.42

Sub ImportExcelToAccess()
    Dim originalFilePath As String
    Dim tempFilePath As String
    Dim xlApp As Object
    Dim xlWorkbook As Object
    Dim xlSheet As Object
    Dim col As Integer
    Dim db As DAO.Database
    
    originalFilePath = "C:\Beta_003\MRL.xlsx"
    tempFilePath = "C:\Beta_003\TempMRL.xlsx"
    
    ' Delete TempTable if it exists
    Set db = CurrentDb()
    On Error Resume Next
    db.Execute "DROP TABLE TempTable"
    On Error GoTo 0
    
    ' Create a copy of the original file
    FileCopy originalFilePath, tempFilePath
    
    ' Create a new Excel application instance
    Set xlApp = CreateObject("Excel.Application")
    ' Open the temp workbook
    Set xlWorkbook = xlApp.Workbooks.Open(tempFilePath)
    ' Set the worksheet
    Set xlSheet = xlWorkbook.Sheets("Sheet1") ' Adjust to your sheet name
    
    ' Clean up field names in the first row: trim and convert to lowercase
    For col = 1 To xlSheet.UsedRange.Columns.count
        xlSheet.Cells(1, col).Value = LCase(Trim(xlSheet.Cells(1, col).Value))
    Next col
    
    ' Save and close the workbook
    xlWorkbook.Save
    xlWorkbook.Close False
    ' Quit Excel application
    xlApp.Quit
    
    ' Clean up
    Set xlSheet = Nothing
    Set xlWorkbook = Nothing
    Set xlApp = Nothing

    ' Import the cleaned Excel file into Access
    DoCmd.TransferSpreadsheet acImport, acSpreadsheetTypeExcel12, "TempTable", tempFilePath, True
    
    ' Delete the temporary file
    Kill tempFilePath
    
    Set db = Nothing
End Sub

'Convert to JSON
'version 0.8.39

Public Function ConvertToJSON() As Variant
    Dim db As DAO.Database
    Dim rs As DAO.Recordset
    Dim json As String
    Dim f As DAO.Field
    Dim keyFields As Collection
    Dim keyField As Variant
    Dim isEmptyRecord As Boolean
    Dim trimmedFieldName As String
    Dim errorLog As String
    Dim recordCount As Long
    Dim errorCount As Long
    
    ' Define the key fields to check
    Set keyFields = New Collection
    keyFields.Add "jcn"
    keyFields.Add "twcode"
    keyFields.Add "qty"
    keyFields.Add "request_date"
    ' Add other key fields as needed

    Set db = CurrentDb()
    Set rs = db.OpenRecordset("SELECT * FROM TempTable")

    If rs.EOF Then
        ConvertToJSON = Array("[]", "No records found.")
        Exit Function
    End If

    json = "["
    errorLog = ""
    recordCount = 0
    errorCount = 0
    
    Do While Not rs.EOF
        recordCount = recordCount + 1
        isEmptyRecord = True
        
        ' Check if key fields are empty
        For Each keyField In keyFields
            On Error Resume Next
            trimmedFieldName = Trim(keyField)
            If IsNull(rs.Fields(trimmedFieldName)) Or rs.Fields(trimmedFieldName).Value = "" Then
                If Err.Number = 0 Then
                    errorLog = errorLog & "Record " & recordCount & ": Empty " & trimmedFieldName & vbCrLf
                Else
                    errorLog = errorLog & "Record " & recordCount & ": Missing field " & trimmedFieldName & vbCrLf
                End If
                errorCount = errorCount + 1
            Else
                isEmptyRecord = False
            End If
            On Error GoTo 0
        Next keyField
        
        If Not isEmptyRecord Then
            json = json & "{"
            For Each f In rs.Fields
                trimmedFieldName = Trim(f.Name)
                json = json & """" & EscapeJSON(trimmedFieldName) & """:"
                On Error Resume Next
                If IsNull(f.Value) Then
                    json = json & "null"
                ElseIf f.Type = dbText Then
                    json = json & """" & EscapeJSON(CStr(f.Value)) & """"
                ElseIf f.Type = dbDate Then
                    json = json & """" & Format(f.Value, "yyyy-mm-ddThh:nn:ss") & """"
                Else
                    json = json & EscapeJSON(CStr(f.Value))
                End If
                If Err.Number <> 0 Then
                    errorLog = errorLog & "Record " & recordCount & ": Error in field " & trimmedFieldName & " - " & Err.Description & vbCrLf
                    errorCount = errorCount + 1
                    Err.Clear
                End If
                On Error GoTo 0
                json = json & ","
            Next f
            json = Left(json, Len(json) - 1) ' Remove trailing comma
            json = json & "},"
        End If

        rs.MoveNext
    Loop
    
    If Right(json, 1) = "," Then
        json = Left(json, Len(json) - 1) ' Remove trailing comma from the last record
    End If
    
    json = json & "]"
    
    rs.Close
    Set rs = Nothing
    Set db = Nothing
    
    errorLog = "Total Records: " & recordCount & vbCrLf & _
               "Records with Errors: " & errorCount & vbCrLf & vbCrLf & errorLog
    
    ConvertToJSON = Array(json, errorLog)
End Function

' version 0.8.39
' Helper function to escape JSON
Private Function EscapeJSON(ByVal text As String) As String
    Dim i As Integer
    Dim char As String
    Dim result As String
    
    For i = 1 To Len(text)
        char = Mid(text, i, 1)
        Select Case AscW(char)
            Case 8:  result = result & "\b"
            Case 9:  result = result & "\t"
            Case 10: result = result & "\n"
            Case 12: result = result & "\f"
            Case 13: result = result & "\r"
            Case 34: result = result & "\"""
            Case 92: result = result & "\\"
            Case 0 To 31
                result = result & "\u" & Right("0000" & Hex(AscW(char)), 4)
            Case Else
                result = result & char
        End Select
    Next i
    
    EscapeJSON = result
End Function

' insert mrl line items
' version 0.8.53

Public Sub InsertMRLLineItems()
    Dim jsonData As Variant
    Dim updateSource As String
    Dim result As Variant
    Dim jsonString As String
    Dim errorLog As String
    
    Set frm = Forms!frMRL
    jsonData = ConvertToJSON()
    jsonString = CStr(jsonData(0))
    errorLog = CStr(jsonData(1))
    updateSource = frm.txtUpdateSource.Value ' Get the update source from the text box
    
    ' Debugging output
    Debug.Print "Function name: insert_mrl_line_items"
    Debug.Print "JSON Data length: " & Len(jsonString)
    Debug.Print "Update Source: " & updateSource
    Debug.Print "Pre-insert Error Log: " & errorLog
    
    ' Call the protected function with correct number of parameters
    result = ExecuteProtectedFunction("insert_mrl_line_items", jsonString, updateSource)
    
    ' Check the result
    If Not IsNull(result) Then
        ' Parse the results
        Dim totalCount As Long, successCount As Long, duplicateCount As Long, errorCount As Long
        Dim parsedResult As Variant
        parsedResult = ParseNoticeMessage(CStr(result))
        
        If IsArray(parsedResult) Then
            totalCount = parsedResult(0)
            successCount = parsedResult(1)
            duplicateCount = parsedResult(2)
            errorCount = parsedResult(3)
            
            ' Log errors and duplicates for later processing
            LogErrorsAndDuplicates totalCount, successCount, duplicateCount, errorCount, errorLog
        Else
            MsgBox "Unexpected result format from insert_mrl_line_items. Check the database logs for details.", vbExclamation
            Exit Sub
        End If
    Else
        MsgBox "Unexpected result type from insert_mrl_line_items. Check the database logs for details.", vbExclamation
        Exit Sub
    End If
    
    ' Display results
    MsgBox "Process completed." & vbNewLine & _
           "Total Records: " & totalCount & vbNewLine & _
           "Successful Inserts: " & successCount & vbNewLine & _
           "Duplicate Records: " & duplicateCount & vbNewLine & _
           "Failed Inserts: " & errorCount & vbNewLine & _
           "See error log for details.", vbInformation
    
    ' Save error logs to a file
    Dim fso As Object
    Dim fileName As String
    Set fso = CreateObject("Scripting.FileSystemObject")
    fileName = "C:\Temp\MRLInsertErrorLog_" & Format(Now, "yyyymmdd_hhnnss") & ".txt"
    fso.CreateTextFile(fileName).Write "Pre-insert Errors:" & vbNewLine & errorLog & vbNewLine & vbNewLine & _
                                       "Insert Process Results:" & vbNewLine & CStr(result)
    MsgBox "Error log has been saved to " & fileName, vbInformation
End Sub



' version 0.8.40
' Helper function to log errors and duplicates
Private Sub LogErrorsAndDuplicates(totalCount As Long, successCount As Long, duplicateCount As Long, errorCount As Long, errorLog As String)
    Dim db As DAO.Database
    Dim rst As DAO.Recordset
    
    Set db = CurrentDb()
    Set rst = db.OpenRecordset("ErrorLog", dbOpenDynaset)
    
    rst.AddNew
    rst!LogDate = Now()
    rst!totalCount = totalCount
    rst!successCount = successCount
    rst!duplicateCount = duplicateCount
    rst!errorCount = errorCount
    rst!ErrorDetails = errorLog
    rst.Update
    
    rst.Close
    Set rst = Nothing
    Set db = Nothing
End Sub

' version 0.8.34
' Helper function to get the number of records in the JSON string

Private Function GetJSONRecordCount(jsonString As String) As Long
    Dim count As Long
    Dim i As Long
    count = 0
    For i = 1 To Len(jsonString)
        If Mid(jsonString, i, 1) = "{" Then
            count = count + 1
        End If
    Next i
    GetJSONRecordCount = count
End Function

' Parse results from error message
' version 0.8.35

Private Sub ParseResults(errorMessage As String, ByRef totalCount As Long, ByRef successCount As Long, ByRef errorCount As Long)
    Dim regex As Object
    Set regex = CreateObject("VBScript.RegExp")
    regex.Pattern = "Total: (\d+), Success: (\d+), Errors: (\d+)"
    regex.Global = False
    
    Dim matches As Object
    Set matches = regex.Execute(errorMessage)
    
    If matches.count > 0 Then
        totalCount = CLng(matches(0).SubMatches(0))
        successCount = CLng(matches(0).SubMatches(1))
        errorCount = CLng(matches(0).SubMatches(2))
    Else
        totalCount = 0
        successCount = 0
        errorCount = 0
    End If
End Sub

' validate excel data
' version 0.8.55
Public Function ValidateExcelData() As Boolean
    Dim xlApp As Object
    Dim xlWorkbook As Object
    Dim xlSheet As Object
    Dim row As Integer
    Dim isValid As Boolean
    Dim colJCN As Integer, colQty As Integer, colRequestDate As Integer, colCreatedBy As Integer
    Dim headerRow As Integer

    ' Create a new Excel application instance
    Set xlApp = CreateObject("Excel.Application")
    ' Open the workbook
    Set xlWorkbook = xlApp.Workbooks.Open("C:\Beta_003\MRL.xlsx")
    ' Set the worksheet
    Set xlSheet = xlWorkbook.Sheets("Sheet1") ' Adjust to your sheet name
    isValid = True
    headerRow = 1 ' Assuming row 1 is the header row

    ' Find the column numbers based on the header names
    colJCN = FindColumnByName(xlSheet, "jcn", headerRow)
    colQty = FindColumnByName(xlSheet, "qty", headerRow)
    colRequestDate = FindColumnByName(xlSheet, "request_date", headerRow)
    colCreatedBy = FindColumnByName(xlSheet, "created_by", headerRow)

    If colJCN = 0 Or colQty = 0 Or colRequestDate = 0 Or colCreatedBy = 0 Then
        MsgBox "Error: One or more required columns are missing."
        ValidateExcelData = False
        Exit Function
    End If

    For row = 2 To xlSheet.Cells(xlSheet.Rows.count, colJCN).End(-4162).row
        If IsEmpty(xlSheet.Cells(row, colJCN)) Then ' Validate jcn
            MsgBox "Error: jcn is required at row " & row
            isValid = False
        End If
        
        If Not IsNumeric(xlSheet.Cells(row, colQty)) Or xlSheet.Cells(row, colQty).Value <= 0 Then ' Validate qty
            MsgBox "Error: qty must be a positive number at row " & row
            isValid = False
        End If
        
        If Not IsDate(xlSheet.Cells(row, colRequestDate)) Then ' Validate request_date
            MsgBox "Error: request_date must be a valid date at row " & row
            isValid = False
        End If
        
        If Not IsNumeric(xlSheet.Cells(row, colCreatedBy)) Then ' Validate created_by
            MsgBox "Error: created_by must be a number at row " & row
            isValid = False
        End If
        
        If Not isValid Then Exit For
    Next row
    
    ' Close the workbook without saving
    xlWorkbook.Close False
    ' Quit Excel application
    xlApp.Quit
    
    ' Clean up
    Set xlSheet = Nothing
    Set xlWorkbook = Nothing
    Set xlApp = Nothing
    
    ValidateExcelData = isValid
End Function

' version 0.8.55
' Helper function to find the column number based on the header name
Private Function FindColumnByName(sheet As Object, columnName As String, headerRow As Integer) As Integer
    Dim col As Integer
    For col = 1 To sheet.Cells(headerRow, sheet.Columns.count).End(-4159).Column
        If sheet.Cells(headerRow, col).Value = columnName Then
            FindColumnByName = col
            Exit Function
        End If
    Next col
    FindColumnByName = 0 ' Return 0 if not found
End Function
        
' execute postgres command
' version 0.7.14.22

Public Sub ExecutePostgresCommand(cmdText As String, ParamArray params() As Variant)
    On Error GoTo ErrorHandler
    
    Dim conn As ADODB.Connection
    Dim cmd As ADODB.Command
    Dim i As Integer

    Set conn = CreatePostgresConnection()
    Set cmd = New ADODB.Command
    cmd.ActiveConnection = conn
    cmd.commandText = cmdText

    For i = LBound(params) To UBound(params)
        cmd.Parameters.Append cmd.CreateParameter("@param" & i + 1, adVarChar, adParamInput, 255, params(i))
    Next i

    cmd.Execute
    Exit Sub

ErrorHandler:
    MsgBox "Error: " & Err.Description, vbCritical
    Exit Sub
End Sub

' Helper function to parse NOTICE message
' version 0.8.53

Private Function ParseNoticeMessage(message As String) As Variant
    Dim result(3) As Long
    Dim matches As Object
    Dim regex As Object
    
    Set regex = CreateObject("VBScript.RegExp")
    regex.Pattern = "Total: (\d+), Success: (\d+), Duplicates: (\d+), Errors: (\d+)"
    regex.Global = False
    
    Set matches = regex.Execute(message)
    
    If matches.count > 0 Then
        result(0) = CLng(matches(0).SubMatches(0)) ' Total
        result(1) = CLng(matches(0).SubMatches(1)) ' Success
        result(2) = CLng(matches(0).SubMatches(2)) ' Duplicates
        result(3) = CLng(matches(0).SubMatches(3)) ' Errors
    Else
        ' If no match is found, set all values to -1 to indicate an error
        result(0) = -1
        result(1) = -1
        result(2) = -1
        result(3) = -1
    End If
    
    ParseNoticeMessage = result
End Function


