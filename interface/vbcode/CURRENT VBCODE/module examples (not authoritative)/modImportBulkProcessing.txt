Option Compare Database
' import and insert mrl line items
' version 0.7.12
Sub ImportAndInsertMRLLineItems()
    If Not ValidateExcelData() Then
        MsgBox "Data validation failed. Please correct the errors and try again."
        Exit Sub
    End If
    
    ImportExcelToAccess
    InsertMRLLineItems
End Sub

' import excel to access
' version 0.8.42

Sub ImportExcelToAccess()
    Dim originalFilePath As String
    Dim tempFilePath As String
    Dim xlApp As Object
    Dim xlWorkbook As Object
    Dim xlSheet As Object
    Dim col As Integer
    Dim db As DAO.Database
    
    originalFilePath = "C:\Beta_003\MRL.xlsx"
    tempFilePath = "C:\Beta_003\TempMRL.xlsx"
    
    ' Delete TempTable if it exists
    Set db = CurrentDb()
    On Error Resume Next
    db.Execute "DROP TABLE TempTable"
    On Error GoTo 0
    
    ' Create a copy of the original file
    FileCopy originalFilePath, tempFilePath
    
    ' Create a new Excel application instance
    Set xlApp = CreateObject("Excel.Application")
    ' Open the temp workbook
    Set xlWorkbook = xlApp.Workbooks.Open(tempFilePath)
    ' Set the worksheet
    Set xlSheet = xlWorkbook.Sheets("Sheet1") ' Adjust to your sheet name
    
    ' Clean up field names in the first row: trim and convert to lowercase
    For col = 1 To xlSheet.UsedRange.Columns.count
        xlSheet.Cells(1, col).Value = LCase(Trim(xlSheet.Cells(1, col).Value))
    Next col
    
    ' Save and close the workbook
    xlWorkbook.Save
    xlWorkbook.Close False
    ' Quit Excel application
    xlApp.Quit
    
    ' Clean up
    Set xlSheet = Nothing
    Set xlWorkbook = Nothing
    Set xlApp = Nothing

    ' Import the cleaned Excel file into Access
    DoCmd.TransferSpreadsheet acImport, acSpreadsheetTypeExcel12, "TempTable", tempFilePath, True
    
    ' Delete the temporary file
    Kill tempFilePath
    
    Set db = Nothing
End Sub

' validate excel data
' version 0.7.12 (reverted)
Public Function ValidateExcelData() As Boolean
    Dim xlApp As Object
    Dim xlWorkbook As Object
    Dim xlSheet As Object
    Dim row As Integer
    Dim isValid As Boolean
    
    ' Create a new Excel application instance
    Set xlApp = CreateObject("Excel.Application")
    ' Open the workbook
    Set xlWorkbook = xlApp.Workbooks.Open("C:\Beta_003\MRL.xlsx")
    ' Set the worksheet
    Set xlSheet = xlWorkbook.Sheets("Sheet1") ' Adjust to your sheet name
    isValid = True
    
    For row = 2 To xlSheet.Cells(xlSheet.Rows.count, "A").End(-4162).row ' Assuming row 1 is the header row
        If IsEmpty(xlSheet.Cells(row, 1)) Then ' Validate jcn
            MsgBox "Error: jcn is required at row " & row
            isValid = False
        End If
        
        If Not IsNumeric(xlSheet.Cells(row, 8)) Or xlSheet.Cells(row, 8).Value <= 0 Then ' Validate qty
            MsgBox "Error: qty must be a positive number at row " & row
            isValid = False
        End If
        
        If Not IsDate(xlSheet.Cells(row, 13)) Then ' Validate request_date
            MsgBox "Error: request_date must be a valid date at row " & row
            isValid = False
        End If
        
        If Not IsNumeric(xlSheet.Cells(row, 28)) Then ' Validate created_by
            MsgBox "Error: created_by must be a number at row " & row
            isValid = False
        End If
        
        ' Additional validation rules can be added here...
        
        If Not isValid Then Exit For
    Next row
    
    ' Close the workbook without saving
    xlWorkbook.Close False
    ' Quit Excel application
    xlApp.Quit
    
    ' Clean up
    Set xlSheet = Nothing
    Set xlWorkbook = Nothing
    Set xlApp = Nothing
    
    ValidateExcelData = isValid
End Function


'Convert to JSON
'version 0.8.60 REVERTED 39

Public Function ConvertToJSON() As Variant
    Dim db As DAO.Database
    Dim rs As DAO.Recordset
    Dim json As String
    Dim f As DAO.Field
    Dim keyFields As Collection
    Dim keyField As Variant
    Dim isEmptyRecord As Boolean
    Dim trimmedFieldName As String
    Dim errorLog As String
    Dim recordCount As Long
    Dim errorCount As Long
    
    ' Define the key fields to check
    Set keyFields = New Collection
    keyFields.Add "jcn"
    keyFields.Add "twcode"
    keyFields.Add "qty"
    keyFields.Add "request_date"
    ' Add other key fields as needed

    Set db = CurrentDb()
    Set rs = db.OpenRecordset("SELECT * FROM TempTable")

    If rs.EOF Then
        ConvertToJSON = Array("[]", "No records found.")
        Exit Function
    End If

    json = "["
    errorLog = ""
    recordCount = 0
    errorCount = 0
    
    Do While Not rs.EOF
        recordCount = recordCount + 1
        isEmptyRecord = True
        
        ' Check if key fields are empty
        For Each keyField In keyFields
            On Error Resume Next
            trimmedFieldName = Trim(keyField)
            If IsNull(rs.Fields(trimmedFieldName)) Or rs.Fields(trimmedFieldName).Value = "" Then
                If Err.Number = 0 Then
                    errorLog = errorLog & "Record " & recordCount & ": Empty " & trimmedFieldName & vbCrLf
                Else
                    errorLog = errorLog & "Record " & recordCount & ": Missing field " & trimmedFieldName & vbCrLf
                End If
                errorCount = errorCount + 1
            Else
                isEmptyRecord = False
            End If
            On Error GoTo 0
        Next keyField
        
        If Not isEmptyRecord Then
            json = json & "{"
            For Each f In rs.Fields
                trimmedFieldName = Trim(f.Name)
                json = json & """" & EscapeJSON(trimmedFieldName) & """:"
                On Error Resume Next
                If IsNull(f.Value) Then
                    json = json & "null"
                ElseIf f.Type = dbText Then
                    json = json & """" & EscapeJSON(CStr(f.Value)) & """"
                ElseIf f.Type = dbDate Then
                    json = json & """" & Format(f.Value, "yyyy-mm-ddThh:nn:ss") & """"
                Else
                    json = json & EscapeJSON(CStr(f.Value))
                End If
                If Err.Number <> 0 Then
                    errorLog = errorLog & "Record " & recordCount & ": Error in field " & trimmedFieldName & " - " & Err.Description & vbCrLf
                    errorCount = errorCount + 1
                    Err.Clear
                End If
                On Error GoTo 0
                json = json & ","
            Next f
            json = Left(json, Len(json) - 1) ' Remove trailing comma
            json = json & "},"
        End If

        rs.MoveNext
    Loop
    
    If Right(json, 1) = "," Then
        json = Left(json, Len(json) - 1) ' Remove trailing comma from the last record
    End If
    
    json = json & "]"
    
    rs.Close
    Set rs = Nothing
    Set db = Nothing
    
    errorLog = "Total Records: " & recordCount & vbCrLf & _
               "Records with Errors: " & errorCount & vbCrLf & vbCrLf & errorLog
    
    ConvertToJSON = Array(json, errorLog)
End Function

' insert mrl line items
' version 0.8.53 (reverted)

Public Sub InsertMRLLineItems()
    Dim jsonData As Variant
    Dim updateSource As String
    Dim result As Variant
    Dim jsonString As String
    Dim errorLog As String
    
    Set frm = Forms!frMRL
    jsonData = ConvertToJSON()
    jsonString = CStr(jsonData(0))
    errorLog = CStr(jsonData(1))
    updateSource = frm.txtUpdateSource.Value ' Get the update source from the text box
    
    ' Debugging output
    Debug.Print "Function name: insert_mrl_line_items"
    Debug.Print "JSON Data length: " & Len(jsonString)
    Debug.Print "Update Source: " & updateSource
    Debug.Print "Pre-insert Error Log: " & errorLog
    
    ' Call the protected function with correct number of parameters
    result = ExecuteProtectedFunction("insert_mrl_line_items", jsonString, updateSource)
    
    ' Check the result
    If Not IsNull(result) Then
        ' Parse the results
        Dim totalCount As Long, successCount As Long, duplicateCount As Long, errorCount As Long
        Dim parsedResult As Variant
        parsedResult = ParseNoticeMessage(CStr(result))
        
        If IsArray(parsedResult) Then
            totalCount = parsedResult(0)
            successCount = parsedResult(1)
            duplicateCount = parsedResult(2)
            errorCount = parsedResult(3)
            
            ' Log errors and duplicates for later processing
            LogErrorsAndDuplicates totalCount, successCount, duplicateCount, errorCount, errorLog
        Else
            MsgBox "Unexpected result format from insert_mrl_line_items. Check the database logs for details.", vbExclamation
            Exit Sub
        End If
    Else
        MsgBox "Unexpected result type from insert_mrl_line_items. Check the database logs for details.", vbExclamation
        Exit Sub
    End If
    
    ' Display results
    MsgBox "Process completed." & vbNewLine & _
           "Total Records: " & totalCount & vbNewLine & _
           "Successful Inserts: " & successCount & vbNewLine & _
           "Duplicate Records: " & duplicateCount & vbNewLine & _
           "Failed Inserts: " & errorCount & vbNewLine & _
           "See error log for details.", vbInformation
    
    ' Save error logs to a file
    Dim fso As Object
    Dim fileName As String
    Set fso = CreateObject("Scripting.FileSystemObject")
    fileName = "C:\Temp\MRLInsertErrorLog_" & Format(Now, "yyyymmdd_hhnnss") & ".txt"
    fso.CreateTextFile(fileName).Write "Pre-insert Errors:" & vbNewLine & errorLog & vbNewLine & vbNewLine & _
                                       "Insert Process Results:" & vbNewLine & CStr(result)
    MsgBox "Error log has been saved to " & fileName, vbInformation
End Sub

' version 0.8.60 REVERTED 39
' Helper function to escape JSON
Private Function EscapeJSON(ByVal text As String) As String
    Dim i As Integer
    Dim char As String
    Dim result As String
    
    For i = 1 To Len(text)
        char = Mid(text, i, 1)
        Select Case AscW(char)
            Case 8:  result = result & "\b"
            Case 9:  result = result & "\t"
            Case 10: result = result & "\n"
            Case 12: result = result & "\f"
            Case 13: result = result & "\r"
            Case 34: result = result & "\"""
            Case 92: result = result & "\\"
            Case 0 To 31
                result = result & "\u" & Right("0000" & Hex(AscW(char)), 4)
            Case Else
                result = result & char
        End Select
    Next i
    
    EscapeJSON = result
End Function


' version 0.8.34
' Helper function to get the number of records in the JSON string

Private Function GetJSONRecordCount(jsonString As String) As Long
    Dim count As Long
    Dim i As Long
    count = 0
    For i = 1 To Len(jsonString)
        If Mid(jsonString, i, 1) = "{" Then
            count = count + 1
        End If
    Next i
    GetJSONRecordCount = count
End Function



