-- version 0.10.18

CREATE OR REPLACE PROCEDURE update_fulfillment_items_efficient(
    IN batch_data JSONB,
    IN v_update_source TEXT,
    OUT summary JSONB
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_success_count INT := 0;
    v_error_count INT := 0;
    v_warning_count INT := 0;
    v_batch_size INT := 1000; -- Define batch size
    v_total_records INT;
    v_batch_start INT;
    v_batch_id UUID;
    v_updated_rows INT;
    v_logged_warnings INT;
    v_inserted_audit_entries INT;
BEGIN
    -- Generate a unique batch ID
    v_batch_id := gen_random_uuid();
    RAISE NOTICE 'Generated batch ID: %', v_batch_id;

    -- Validate batch_data
    IF batch_data IS NULL OR jsonb_typeof(batch_data) != 'array' THEN
        RAISE EXCEPTION 'Invalid batch_data: not a JSON array or is NULL';
    END IF;

    -- Get total number of records
    v_total_records := jsonb_array_length(batch_data);
    RAISE NOTICE 'Total records to process: %', v_total_records;

    -- Create temporary tables once
    CREATE TEMP TABLE IF NOT EXISTS temp_fulfillment_updates (
        fulfillment_item_id INT,
        shipdoc_tcn VARCHAR,
        v2x_ship_no VARCHAR,
        booking VARCHAR,
        vessel VARCHAR,
        container VARCHAR,
        carrier VARCHAR,
        sail_date DATE,
        edd_to_ches DATE,
        edd_egypt DATE,
        rcd_v2x_date DATE,
        lot_id VARCHAR,
        triwall VARCHAR,
        lsc_on_hand_date DATE,
        arr_lsc_egypt DATE,
        milstrip_req_no VARCHAR,
        comments TEXT,
        update_source TEXT
    ) ON COMMIT DROP;

    CREATE TEMP TABLE IF NOT EXISTS temp_multiple_records (
        jcn VARCHAR,
        twcode VARCHAR,
        record_count INT
    ) ON COMMIT DROP;

    -- Process records in batches
    FOR v_batch_start IN 0..v_total_records-1 BY v_batch_size LOOP
        -- Begin block for each batch processing
        BEGIN
            RAISE NOTICE 'Processing batch starting at record: %', v_batch_start;

            -- Truncate temporary tables
            TRUNCATE TABLE temp_fulfillment_updates;
            TRUNCATE TABLE temp_multiple_records;

            -- Insert batch data into temporary table
            INSERT INTO temp_fulfillment_updates
            SELECT
                NULLIF(item ->> 'fulfillment_item_id', '')::INT AS fulfillment_item_id,
                NULLIF(item ->> 'shipdoc_tcn', '') AS shipdoc_tcn,
                NULLIF(item ->> 'v2x_ship_no', '') AS v2x_ship_no,
                NULLIF(item ->> 'booking', '') AS booking,
                NULLIF(item ->> 'vessel', '') AS vessel,
                NULLIF(item ->> 'container', '') AS container,
                NULLIF(item ->> 'carrier', '') AS carrier,
                NULLIF(item ->> 'sail_date', '')::DATE AS sail_date,
                NULLIF(item ->> 'edd_to_ches', '')::DATE AS edd_to_ches,
                NULLIF(item ->> 'edd_egypt', '')::DATE AS edd_egypt,
                NULLIF(item ->> 'rcd_v2x_date', '')::DATE AS rcd_v2x_date,
                NULLIF(item ->> 'lot_id', '') AS lot_id,
                NULLIF(item ->> 'triwall', '') AS triwall,
                NULLIF(item ->> 'lsc_on_hand_date', '')::DATE AS lsc_on_hand_date,
                NULLIF(item ->> 'arr_lsc_egypt', '')::DATE AS arr_lsc_egypt,
                NULLIF(item ->> 'milstrip_req_no', '') AS milstrip_req_no,
                NULLIF(item ->> 'comments', '') AS comments,
                v_update_source AS update_source
            FROM jsonb_array_elements(batch_data) AS item
            OFFSET v_batch_start LIMIT v_batch_size;

            -- Log number of records inserted into temp_fulfillment_updates
            RAISE NOTICE 'Inserted % records into temp_fulfillment_updates', (SELECT COUNT(*) FROM temp_fulfillment_updates);

            -- Detect multiple fulfillment records for a single jcn and twcode
            INSERT INTO temp_multiple_records
            SELECT mli.jcn, mli.twcode, COUNT(*) AS record_count
            FROM fulfillment_items fi
            JOIN temp_fulfillment_updates tu ON fi.fulfillment_item_id = tu.fulfillment_item_id
            JOIN MRL_line_items mli ON fi.order_line_item_id = mli.order_line_item_id
            GROUP BY mli.jcn, mli.twcode
            HAVING COUNT(*) > 1;

            -- Log number of multiple records detected
            v_logged_warnings := (SELECT COUNT(*) FROM temp_multiple_records);
            RAISE NOTICE 'Detected % multiple fulfillment records', v_logged_warnings;

            -- Log warnings for multiple records
            INSERT INTO import_error_log (
                batch_id, operation_type, source_file_line_number, jcn, twcode,
                error_type, error_message, record_data, created_at
            )
            SELECT
                v_batch_id,
                'FULFILLMENT_UPDATE',
                tu.fulfillment_item_id, -- Assuming fulfillment_item_id maps to source_file_line_number
                mli.jcn,
                mli.twcode,
                'WARNING',
                'Multiple fulfillment records found for this JCN and TWCODE',
                row_to_json(tu)::jsonb, -- Cast the entire record to jsonb
                NOW()
            FROM fulfillment_items fi
            JOIN temp_fulfillment_updates tu ON fi.fulfillment_item_id = tu.fulfillment_item_id
            JOIN MRL_line_items mli ON fi.order_line_item_id = mli.order_line_item_id
            JOIN temp_multiple_records mr ON mli.jcn = mr.jcn AND mli.twcode = mr.twcode;

            RAISE NOTICE 'Logged % warning records', v_logged_warnings;

            -- Increment warning count
            v_warning_count := v_warning_count + v_logged_warnings;

            -- Update only records with single fulfillment records
            UPDATE fulfillment_items
            SET
                shipdoc_tcn = tu.shipdoc_tcn,
                v2x_ship_no = tu.v2x_ship_no,
                booking = tu.booking,
                vessel = tu.vessel,
                container = tu.container,
                carrier = tu.carrier,
                sail_date = tu.sail_date,
                edd_to_ches = tu.edd_to_ches,
                edd_egypt = tu.edd_egypt,
                rcd_v2x_date = tu.rcd_v2x_date,
                lot_id = tu.lot_id,
                triwall = tu.triwall,
                lsc_on_hand_date = tu.lsc_on_hand_date,
                arr_lsc_egypt = tu.arr_lsc_egypt,
                milstrip_req_no = tu.milstrip_req_no,
                comments = tu.comments,
                updated_by = current_setting('myapp.user_id')::INT,
                updated_at = NOW(),
                update_source = tu.update_source
            FROM temp_fulfillment_updates tu
            JOIN MRL_line_items mli ON fulfillment_items.order_line_item_id = mli.order_line_item_id
            LEFT JOIN temp_multiple_records mr ON mli.jcn = mr.jcn AND mli.twcode = mr.twcode
            WHERE fulfillment_items.fulfillment_item_id = tu.fulfillment_item_id
              AND mr.jcn IS NULL AND mr.twcode IS NULL;

            -- Get the number of updated rows
            GET DIAGNOSTICS v_updated_rows = ROW_COUNT;
            RAISE NOTICE 'Updated % records', v_updated_rows;

            -- Increment success count
            v_success_count := v_success_count + v_updated_rows;

            -- Insert audit trail entries for successful updates
            INSERT INTO audit_trail (
                fulfillment_item_id,
                action,
                changed_by,
                changed_at,
                details,
                update_source,
                role_id,
                user_id
            )
            SELECT
                tu.fulfillment_item_id,
                'UPDATE',
                current_setting('myapp.user_id')::INT,
                NOW(),
                'Fulfillment item updated',
                tu.update_source,
                current_setting('myapp.role_id')::INT,
                current_setting('myapp.user_id')::INT
            FROM temp_fulfillment_updates tu
            JOIN fulfillment_items fi ON fi.fulfillment_item_id = tu.fulfillment_item_id
            JOIN MRL_line_items mli ON fi.order_line_item_id = mli.order_line_item_id
            LEFT JOIN temp_multiple_records mr ON mli.jcn = mr.jcn AND mli.twcode = mr.twcode
            WHERE mr.jcn IS NULL AND mr.twcode IS NULL;

            -- Get the number of inserted audit trail entries
            GET DIAGNOSTICS v_inserted_audit_entries = ROW_COUNT;
            RAISE NOTICE 'Inserted % audit trail entries', v_inserted_audit_entries;

        END; -- End of the block for batch processing
    END LOOP; -- End of loop

    -- Prepare summary
    summary := jsonb_build_object(
        'status', 'completed',
        'total', v_total_records,
        'success', v_success_count,
        'warnings', v_warning_count,
        'errors', v_error_count, -- Currently errors are handled via exceptions
        'operation', 'update_fulfillment_items_efficient',
        'timestamp', current_timestamp
    );

EXCEPTION WHEN OTHERS THEN
    -- Handle exceptions and log errors
    DROP TABLE IF EXISTS temp_multiple_records;
    DROP TABLE IF EXISTS temp_fulfillment_updates;
    INSERT INTO import_error_log (
        batch_id, operation_type, source_file_line_number, jcn, twcode,
        error_type, error_message, record_data, created_at
    )
    VALUES (
        v_batch_id,
        'FULFILLMENT_UPDATE',
        NULL, -- source_file_line_number not available here
        NULL, -- jcn not available
        NULL, -- twcode not available
        'ERROR',
        'Unhandled exception: ' || SQLERRM,
        NULL::jsonb, -- cast NULL to jsonb type
        NOW()
    );
    summary := jsonb_build_object(
        'status', 'error',
        'message', 'Unhandled exception: ' || SQLERRM,
        'operation', 'update_fulfillment_items_efficient',
        'timestamp', current_timestamp
    );
END;
$$;
